<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1.排序的概念及应用1.1排序的概念排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中r[i]&#x3D;r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。内部排">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2023/08/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.排序的概念及应用1.1排序的概念排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中r[i]&#x3D;r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。内部排">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200217132155546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200217133800694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200217134902456.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200217135402404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200217142556798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200217143707201.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020021714494453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200217151559362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200217203033588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200217203533372.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200217203548117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200217204109978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200217213050231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200217213721423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200217213710579.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200217215505952.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200217215611543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200217215636310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2023-08-08T15:24:13.044Z">
<meta property="article:modified_time" content="2023-08-08T15:24:13.044Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200217132155546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-排序算法——一篇文章搞懂常用的排序算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2023-08-08T15:24:13.044Z" itemprop="datePublished">2023-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-排序的概念及应用"><a href="#1-排序的概念及应用" class="headerlink" title="1.排序的概念及应用"></a>1.排序的概念及应用</h2><h4 id="1-1排序的概念"><a href="#1-1排序的概念" class="headerlink" title="1.1排序的概念"></a>1.1排序的概念</h4><p><strong>排序</strong>：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。<br>稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中r[i]&#x3D;r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。<br><strong>内部排序</strong>：数据元素全部放在内存中的排序。<br><strong>外部排序</strong>：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序</p>
<h4 id="1-2常见的排序算法"><a href="#1-2常见的排序算法" class="headerlink" title="1.2常见的排序算法"></a>1.2常见的排序算法</h4><p><img src="https://img-blog.csdnimg.cn/20200217132155546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2常见排序算法的实现"><a href="#2常见排序算法的实现" class="headerlink" title="2常见排序算法的实现"></a>2常见排序算法的实现</h2><h3 id="2-1插入排序"><a href="#2-1插入排序" class="headerlink" title="2.1插入排序"></a>2.1插入排序</h3><h4 id="2-1-1直接插入排序"><a href="#2-1-1直接插入排序" class="headerlink" title="2.1.1直接插入排序"></a>2.1.1<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/8255911#1">直接插入排序</a></h4><h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h5><p>当插入第i(i&gt;&#x3D;1)个元素时，前面的array[0],array[1],…,array[i-1]已经排好序，此时用array[i]的排序码与array[i-1],array[i-2],…的排序码顺序进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移<br><img src="https://img-blog.csdnimg.cn/20200217133800694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[] = &#123; 43, 2, 3, 5, 76, 87, 45, 345, 5 &#125;;</span><br><span class="line">	int k = sizeof(a) / sizeof(a[0]);</span><br><span class="line">	int i = 0, j = 0;</span><br><span class="line">	for (i = 1; i &lt; k; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (a[i] &lt; a[i - 1])</span><br><span class="line">		&#123;</span><br><span class="line">			int tmp = a[i];</span><br><span class="line">			for (j = i - 1; j&gt;=0 &amp;&amp; a[j] &gt; tmp; j--)&#123;</span><br><span class="line">				a[j+1] = a[j];</span><br><span class="line">			&#125;</span><br><span class="line">			a[j + 1] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 0; i &lt; k; i++)</span><br><span class="line">		cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://img-blog.csdnimg.cn/20200217134902456.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>直接插入排序的特性总结：</p>
<ol>
<li>元素集合越接近有序，直接插入排序算法的时间效率越高</li>
<li>时间复杂度：O(N^2)</li>
<li>空间复杂度：O(1)，它是一种稳定的排序算法</li>
<li>稳定性：稳定</li>
</ol>
</blockquote>
<h4 id="2-1-2希尔排序（缩小增量排序）"><a href="#2-1-2希尔排序（缩小增量排序）" class="headerlink" title="2.1.2希尔排序（缩小增量排序）"></a>2.1.2<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/3229428?fr=aladdin">希尔排序</a>（缩小增量排序）</h4><h5 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h5><p>希尔排序法又称缩小增量法。希尔排序法的基本思想是：先选定一个整数，把待排序文件中所有记录分成个组，所有距离为的记录分在同一组内，并对每一组内的记录进行排序。然后，取，重复上述分组和排序的工作。当到达&#x3D;1时，所有记录在统一组内排好序。<br><img src="https://img-blog.csdnimg.cn/20200217135402404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void shellsort(vector&lt;int&gt; &amp;res,int len)</span><br><span class="line">&#123;</span><br><span class="line">	int d = len;</span><br><span class="line">	while (d &gt; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		d = (d + 1) / 2;</span><br><span class="line">		for (int i = 0; i &lt; len - d; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (res[i + d] &lt; res[i])</span><br><span class="line">			&#123;</span><br><span class="line">				int tmp = res[i];</span><br><span class="line">				res[i] = res[i + d];</span><br><span class="line">				res[i + d] = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; res;</span><br><span class="line">	int tmp = 0;</span><br><span class="line">	cout &lt;&lt; &quot;请输入要排序的数字并以任意字符作为结尾&quot; &lt;&lt; endl;</span><br><span class="line">	while (cin&gt;&gt;tmp)</span><br><span class="line">	&#123;</span><br><span class="line">		res.push_back(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	shellsort(res, res.size());</span><br><span class="line">	for (int i = 0; i &lt; res.size(); i++)</span><br><span class="line">		cout &lt;&lt; res[i] &lt;&lt; endl;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200217142556798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>希尔排序的特性总结：<br><strong>1. 希尔排序是对直接插入排序的优化。<br>2. 当gap &gt; 1时都是预排序，目的是让数组更接近于有序。当gap &#x3D;&#x3D; 1时，数组已经接近有序的了，这样就会很快。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。<br>3. 希尔排序的时间复杂度不好计算，需要进行推导，推导出来平均时间复杂度： O(N^1.3—N^2）<br>4. 稳定性：不稳定</strong></p>
</blockquote>
<h3 id="2-2选择排序"><a href="#2-2选择排序" class="headerlink" title="2.2选择排序"></a>2.2选择排序</h3><h4 id="2-2-1基本思想："><a href="#2-2-1基本思想：" class="headerlink" title="2.2.1基本思想："></a>2.2.1基本思想：</h4><p>每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完 。</p>
<h4 id="2-2-2直接选择排序"><a href="#2-2-2直接选择排序" class="headerlink" title="2.2.2直接选择排序:"></a>2.2.2<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/2090477?fr=aladdin">直接选择排序</a>:</h4><ul>
<li>在元素集合array[i]–array[n-1]中选择关键码最大(小)的数据元素</li>
<li>若它不是这组元素中的最后一个(第一个)元素，则将它与这组元素中的最后一个（第一个）元素交换</li>
<li>在剩余的array[i]–array[n-2]（array[i+1]–array[n-1]）集合中，重复上述步骤，直到集合剩余1个元素<br><img src="https://img-blog.csdnimg.cn/20200217143707201.gif" alt="在这里插入图片描述"><br>代码实现：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void selectsort(vector&lt;int&gt; &amp;res, int len)</span><br><span class="line">&#123;</span><br><span class="line">	int i=0, j=0, m = 0;</span><br><span class="line">	for (int i = 0; i &lt; len - 1; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m = i;</span><br><span class="line">		for (j = i + 1; j &lt; len;j++)</span><br><span class="line">		if (res[j]&lt;res[m]) m = j;</span><br><span class="line">		if (m != i)&#123;</span><br><span class="line">			int tmp = res[i];</span><br><span class="line">			res[i] = res[m];</span><br><span class="line">			res[m] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; res;</span><br><span class="line">	int tmp = 0;</span><br><span class="line">	cout &lt;&lt; &quot;请输入要排序的数字并以任意字符作为结尾&quot; &lt;&lt; endl;</span><br><span class="line">	while (cin &gt;&gt; tmp)</span><br><span class="line">	&#123;</span><br><span class="line">		res.push_back(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	selectsort(res, res.size());</span><br><span class="line">	for (int i = 0; i &lt; res.size(); i++)</span><br><span class="line">		cout &lt;&lt; res[i] &lt;&lt; endl;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="https://img-blog.csdnimg.cn/2020021714494453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>直接选择排序的特性总结：</p>
<ol>
<li><strong>直接选择排序思考非常好理解，但是效率不是很好。实际中很少使用</strong></li>
<li><strong>时间复杂度：O(N^2)</strong></li>
<li><strong>空间复杂度：O(1)</strong></li>
<li><strong>稳定性：不稳定</strong></li>
</ol>
</blockquote>
<h4 id="2-2-3堆排序"><a href="#2-2-3堆排序" class="headerlink" title="2.2.3堆排序"></a>2.2.3堆排序</h4><p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。它是通过堆来进行选择数据。需要注意的是排升序要建大堆，排降序建小堆。<br><img src="https://img-blog.csdnimg.cn/20200217151559362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void max_heapify(vector&lt;int&gt;&amp; arr, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">	//建立父节点指标和子节点指标</span><br><span class="line">	int dad = start;</span><br><span class="line">	int son = dad * 2 + 1;</span><br><span class="line">	while (son &lt;= end)  //若子节点指标在范围内才做比较</span><br><span class="line">	&#123;</span><br><span class="line">		if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) //先比较两个子节点大小，选择最大的</span><br><span class="line">			son++;</span><br><span class="line">		if (arr[dad] &gt; arr[son]) //如果父节点大於子节点代表调整完毕，直接跳出函数</span><br><span class="line">			return;</span><br><span class="line">		else  //否则交换父子内容再继续子节点和孙节点比较</span><br><span class="line">		&#123;</span><br><span class="line">			swap(arr[dad], arr[son]);</span><br><span class="line">			dad = son;</span><br><span class="line">			son = dad * 2 + 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void heap_sort(vector&lt;int&gt; &amp;arr, int len)</span><br><span class="line">&#123;</span><br><span class="line">	//初始化，i从最後一个父节点开始调整</span><br><span class="line">	for (int i = len / 2 - 1; i &gt;= 0; i--)</span><br><span class="line">		max_heapify(arr, i, len - 1);</span><br><span class="line">	//先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕</span><br><span class="line">	for (int i = len - 1; i &gt; 0; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		swap(arr[0], arr[i]);</span><br><span class="line">		max_heapify(arr, 0, i - 1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; res;</span><br><span class="line">	int tmp = 0;</span><br><span class="line">	cout &lt;&lt; &quot;请输入要排序的数字并以任意字符作为结尾&quot; &lt;&lt; endl;</span><br><span class="line">	while (cin &gt;&gt; tmp)</span><br><span class="line">	&#123;</span><br><span class="line">		res.push_back(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	heap_sort(res, res.size());</span><br><span class="line">	for (int i = 0; i &lt; res.size(); i++)</span><br><span class="line">		cout &lt;&lt; res[i] &lt;&lt; endl;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200217203033588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>堆排序的特性总结：</p>
<ol>
<li>堆排序使用堆来选数，效率就高了很多。</li>
<li>时间复杂度：O(N*logN)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ol>
</blockquote>
<h3 id="2-3交换排序"><a href="#2-3交换排序" class="headerlink" title="2.3交换排序"></a>2.3交换排序</h3><p><strong>基本思想：</strong><br>所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。</p>
<h4 id="2-3-1冒泡排序"><a href="#2-3-1冒泡排序" class="headerlink" title="2.3.1冒泡排序"></a>2.3.1冒泡排序</h4><p><img src="https://img-blog.csdnimg.cn/20200217203533372.gif" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200217203548117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70"><br>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void bubble_sort(vector&lt;int&gt;&amp; arr, int len)</span><br><span class="line">&#123;</span><br><span class="line">	int i, j;  int temp;</span><br><span class="line">	for (i = 0; i &lt; len - 1; i++)</span><br><span class="line">	for (j = 0; j &lt; len - 1 - i; j++)</span><br><span class="line">	if (arr[j] &gt; arr[j + 1])</span><br><span class="line">	&#123;</span><br><span class="line">		temp = arr[j];</span><br><span class="line">		arr[j] = arr[j + 1];</span><br><span class="line">		arr[j + 1] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; res;</span><br><span class="line">	int tmp = 0;</span><br><span class="line">	cout &lt;&lt; &quot;请输入要排序的数字并以任意字符作为结尾&quot; &lt;&lt; endl;</span><br><span class="line">	while (cin &gt;&gt; tmp)</span><br><span class="line">	&#123;</span><br><span class="line">		res.push_back(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	bubble_sort(res, res.size());</span><br><span class="line">	for (int i = 0; i &lt; res.size(); i++)</span><br><span class="line">		cout &lt;&lt; res[i] &lt;&lt; endl;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200217204109978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>冒泡排序的特性总结：</p>
<ol>
<li>冒泡排序是一种非常容易理解的排序</li>
<li>时间复杂度：O(N^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
</ol>
</blockquote>
<h4 id="2-3-2快速排序"><a href="#2-3-2快速排序" class="headerlink" title="2.3.2快速排序"></a>2.3.2快速排序</h4><p>是Hoare于1962年提出的一种二叉树结构的交换排序方法，其基本思想为：任取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。<br>将区间按照基准值划分为左右两半部分的常见方式有：</p>
<ol>
<li>hoare版本</li>
<li>挖坑法</li>
<li>前后指针版本<br>代码实现（递归）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void Qsort(vector&lt;int&gt;&amp; arr, int low, int high)&#123;</span><br><span class="line">	if (high &lt;= low) return;</span><br><span class="line">	int i = low;</span><br><span class="line">	int j = high + 1;</span><br><span class="line">	int key = arr[low];</span><br><span class="line">	while (true)</span><br><span class="line">	&#123;</span><br><span class="line">		/*从左向右找比key大的值*/</span><br><span class="line">		while (arr[++i] &lt; key)</span><br><span class="line">		&#123;</span><br><span class="line">			if (i == high)&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		/*从右向左找比key小的值*/</span><br><span class="line">		while (arr[--j] &gt; key)</span><br><span class="line">		&#123;</span><br><span class="line">			if (j == low)&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (i &gt;= j) break;</span><br><span class="line">		/*交换i,j对应的值*/</span><br><span class="line">		int temp = arr[i];</span><br><span class="line">		arr[i] = arr[j];</span><br><span class="line">		arr[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	/*中枢值与j对应值交换*/</span><br><span class="line">	int temp = arr[low];</span><br><span class="line">	arr[low] = arr[j];</span><br><span class="line">	arr[j] = temp;</span><br><span class="line">	Qsort(arr, low, j - 1);</span><br><span class="line">	Qsort(arr, j + 1, high);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; res;</span><br><span class="line">	int tmp = 0;</span><br><span class="line">	cout &lt;&lt; &quot;请输入要排序的数字并以任意字符作为结尾&quot; &lt;&lt; endl;</span><br><span class="line">	while (cin &gt;&gt; tmp)</span><br><span class="line">	&#123;</span><br><span class="line">		res.push_back(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	Qsort(res,0, res.size()-1);</span><br><span class="line">	for (int i = 0; i &lt; res.size(); i++)</span><br><span class="line">		cout &lt;&lt; res[i] &lt;&lt; endl;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行结果：<br><img src="https://img-blog.csdnimg.cn/20200217213050231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><blockquote>
<p>快速排序的特性总结：</p>
<ol>
<li>快速排序整体的综合性能和使用场景都是比较好的，所以才敢叫快速排序</li>
<li>时间复杂度：O(N*logN)</li>
<li>空间复杂度：O(logN)</li>
<li>稳定性：不稳定</li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="2-4归并排序"><a href="#2-4归并排序" class="headerlink" title="2.4归并排序"></a>2.4归并排序</h3><p><strong>基本思想</strong>：<br>归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br><img src="https://img-blog.csdnimg.cn/20200217213721423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200217213710579.gif" alt="在这里插入图片描述"><br>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/**将a开头的长为length的数组和b开头长为right的数组合并n为数组长度，用于最后一组*/</span><br><span class="line">void　Merge(int*　data,int　a,int　b,int　length,int　n)&#123;</span><br><span class="line">　int　right;</span><br><span class="line">　if(b+length-1 &gt;= n-1)　right = n-b;</span><br><span class="line">　else　right = length;</span><br><span class="line">　int*　temp = new　int[length+right];</span><br><span class="line">　int　i=0, j=0;</span><br><span class="line">　while(i&lt;=length-1 &amp;&amp; j&lt;=right-1)&#123;</span><br><span class="line">    　if(data[a+i] &lt;= data[b+j])&#123;</span><br><span class="line">    　    temp[i+j] = data[a+i];i++;</span><br><span class="line">      &#125;</span><br><span class="line">    　else&#123;</span><br><span class="line">        temp[i+j] = data[b+j];</span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">　&#125;</span><br><span class="line">　if(j == right)&#123;//a中还有元素，且全都比b中的大,a[i]还未使用</span><br><span class="line">　  memcpy(temp + i + j, data + a + i, (length - i) * sizeof(int));</span><br><span class="line">　&#125;</span><br><span class="line">  else if(i == length)&#123;</span><br><span class="line">      memcpy(temp + i + j, data + b + j, (right - j)*sizeof(int));</span><br><span class="line">  &#125;</span><br><span class="line">　memcpy(data+a, temp, (right + length) * sizeof(int));</span><br><span class="line">　delete [] temp;</span><br><span class="line">&#125;</span><br><span class="line">void　MergeSort(int*　data, int　n)&#123;</span><br><span class="line">　int　step = 1;</span><br><span class="line">　while(step &lt; n)&#123;</span><br><span class="line">    　for(int　i=0; i&lt;=n-step-1; i+=2*step)</span><br><span class="line">    　    Merge(data, i, i+step, step, n);</span><br><span class="line">    //将i和i+step这两个有序序列进行合并</span><br><span class="line">    //序列长度为step</span><br><span class="line">    //当i以后的长度小于或者等于step时，退出</span><br><span class="line">    　step*=2;//在按某一步长归并序列之后，步长加倍</span><br><span class="line">　&#125;</span><br><span class="line">&#125;</span><br><span class="line">int　main()&#123;</span><br><span class="line">　int　n;</span><br><span class="line">　cin&gt;&gt;n;</span><br><span class="line">　int*　data = new　int[n];</span><br><span class="line">　if(!data)　exit(1);</span><br><span class="line">　int　k = n;</span><br><span class="line">　while(k--)&#123;</span><br><span class="line">　    cin&gt;&gt;data[n-k-1];</span><br><span class="line">　&#125;</span><br><span class="line">　clock_t　s = clock();</span><br><span class="line">　MergeSort(data, n);</span><br><span class="line">　clock_t　e = clock();</span><br><span class="line">　k=n;</span><br><span class="line">　while(k--)&#123;</span><br><span class="line">　    cout&lt;&lt;data[n-k-1]&lt;&lt;&#x27; &#x27;;</span><br><span class="line">　&#125;</span><br><span class="line">　cout&lt;&lt;endl;</span><br><span class="line">　cout&lt;&lt;&quot;the algorithm used&quot;&lt;&lt;e-s&lt;&lt;&quot;miliseconds.&quot;&lt;&lt;endl;</span><br><span class="line">　delete　data;</span><br><span class="line">　return　0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">递归算法：</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void merge(int *data, int start, int mid, int end, int *result)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k;</span><br><span class="line">    i = start;</span><br><span class="line">    j = mid + 1;                        //避免重复比较data[mid]</span><br><span class="line">    k = 0;</span><br><span class="line">    while (i &lt;= mid &amp;&amp; j &lt;= end)        //数组data[start,mid]与数组(mid,end]均没有全部归入数组result中去</span><br><span class="line">    &#123;</span><br><span class="line">        if (data[i] &lt;= data[j])         //如果data[i]小于等于data[j]</span><br><span class="line">            result[k++] = data[i++];    //则将data[i]的值赋给result[k]，之后i,k各加一，表示后移一位</span><br><span class="line">        else</span><br><span class="line">            result[k++] = data[j++];    //否则，将data[j]的值赋给result[k]，j,k各加一</span><br><span class="line">    &#125;</span><br><span class="line">    while (i &lt;= mid)                    //表示数组data(mid,end]已经全部归入result数组中去了，而数组data[start,mid]还有剩余</span><br><span class="line">        result[k++] = data[i++];        //将数组data[start,mid]剩下的值，逐一归入数组result</span><br><span class="line">    while (j &lt;= end)                    //表示数组data[start,mid]已经全部归入到result数组中去了，而数组(mid,high]还有剩余</span><br><span class="line">        result[k++] = data[j++];        //将数组a[mid,high]剩下的值，逐一归入数组result</span><br><span class="line"> </span><br><span class="line">    for (i = 0; i &lt; k; i++)             //将归并后的数组的值逐一赋给数组data[start,end]</span><br><span class="line">        data[start + i] = result[i];    //注意，应从data[start+i]开始赋值</span><br><span class="line">&#125;</span><br><span class="line">void merge_sort(int *data, int start, int end, int *result)</span><br><span class="line">&#123;</span><br><span class="line">    if (start &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = start + (end-start) / 2;//避免溢出int</span><br><span class="line">        merge_sort(data, start, mid, result);                    //对左边进行排序</span><br><span class="line">        merge_sort(data, mid + 1, end, result);                  //对右边进行排序</span><br><span class="line">        merge(data, start, mid, end, result);                    //把排序好的数据合并</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void amalgamation(int *data1, int *data2, int *result)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">        result[i] = data1[i];</span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">        result[i + 10] = data2[i];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int data1[10] = &#123; 1,7,6,4,9,14,19,100,55,10 &#125;;</span><br><span class="line">    int data2[10] = &#123; 2,6,8,99,45,63,102,556,10,41 &#125;;</span><br><span class="line">    int *result = new int[20];                              </span><br><span class="line">    int *result1 = new int[20];</span><br><span class="line">    amalgamation(data1, data2, result);</span><br><span class="line">    for (int i = 0; i &lt; 20; ++i)</span><br><span class="line">        cout &lt;&lt; result[i] &lt;&lt; &quot;  &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    merge_sort(result, 0, 19, result1);</span><br><span class="line">    for (int i = 0; i &lt; 20; ++i)</span><br><span class="line">        cout &lt;&lt; result[i] &lt;&lt; &quot;  &quot;;</span><br><span class="line">    delete[]result;</span><br><span class="line">    delete[]result1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>归并排序特性总结：</p>
<ol>
<li>归并的缺点在于需要O(N)的空间复杂度，归并排序的思考更多的是解决在磁盘中的外排序问题。</li>
<li>时间复杂度：O(N*logN)</li>
<li>空间复杂度：O(N)</li>
<li>稳定性：稳定</li>
</ol>
</blockquote>
<h3 id="2-5计数排序"><a href="#2-5计数排序" class="headerlink" title="2.5计数排序"></a>2.5计数排序</h3><p>思想：计数排序又称为鸽巢原理，是对哈希直接定址法的变形应用。 操作步骤：</p>
<ol>
<li>统计相同元素出现次数</li>
<li>根据统计的结果将序列回收到原来的序列中<br>代码实现：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 100000;</span><br><span class="line">const int k = 1000; // range(范围)</span><br><span class="line">int a[MAXN], c[MAXN], ranked[MAXN];</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i]; </span><br><span class="line">        ++c[a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; k; ++i)</span><br><span class="line">        c[i] += c[i-1];</span><br><span class="line">    for (int i = n-1; i &gt;= 0; --i)</span><br><span class="line">        ranked[--c[a[i]]] = a[i];//如果是i表达的是原数标号，a[i]就是排序后的正确序列</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">        cout &lt;&lt; ranked[i] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200217215505952.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>计数排序的特性总结：<br> 计数排序在数据范围集中时，效率很高，但是适用范围及场景有限。<br>  时间复杂度：O(MAX(N,范围))<br>  空间复杂度：O(范围)<br>  稳定性：稳定</p>
</blockquote>
<h3 id="排序算法复杂度与稳定性分析"><a href="#排序算法复杂度与稳定性分析" class="headerlink" title="排序算法复杂度与稳定性分析"></a>排序算法复杂度与稳定性分析</h3><p><img src="https://img-blog.csdnimg.cn/20200217215611543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200217215636310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNjM1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-id="cll2gkc3r0000h6vhdsca75qu" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2023/08/08/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/08/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>